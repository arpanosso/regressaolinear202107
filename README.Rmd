---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Determinação de fontes e sumidouros de carbono atmosférico no Brasil por meio da análise de regressão linear

### Aluno: Alan R. Panosso
### Data: 31/08/2021

Projeto final apresentado os instrutores Athos Damiani e Fernando Correa da Curso-R como parte das exigências para a finalização do curso de **Regressão Linear** (Trilha de Machine Learning - Turma Agosto 2021).

## Introdução

As concentrações atmosféricas de gases do efeito estufa (GEE) têm aumentado a níveis preocupantes. De acordo com a **Organização Meteorológica Mundial** (*WMO*) as concentrações atmosféricas de dióxido de carbono (CO~2~), metano (CH~4~) e óxido nitroso (N~2~O) atingiram novas máximas no ano de 2015 com CO~2~ a 400,0 ± 0,1 ppm, CH~4~ em 1845 ± 2 ppb e N~2~O em 328,0 ± 0,1 ppb, valores que representam, respectivamente, 144%, 256% e 121% dos níveis pré-industriais ([WMO, 2016](http://ane4bf-datap1.s3-eu-west-1.amazonaws.com/wmocms/s3fs-public/GHG_Bulletin_12_EN_web_JN161640.pdf?aZaKZhdpDfJdmHvtbSvLwbj6zb_PWwdz)). 

O Observatório Orbital de Carbono-2 (OCO-2) foi projetado pela **Agência Espacial Americana** (*National Aeronautics and Space Administration - NASA*) para apoiar a quantificação e o monitoramento das emissões antropogênicas de CO~2~. 

O satélite OCO-2 foi lançado em órbita em julho de 2014 e desde então mede a concentração de CO~2~ atmosférico indiretamente por meio da intensidade da radiação solar refletida em função da presença de dióxido de carbono em uma coluna de ar. Essas medições resultam em mapas espaciais densos e em escala fina de frações molares médias de coluna de ar seco de dióxido de carbono (X~CO2~).

Nesse contexto, a variação de X~CO2~ opode ser modelada por meio da **análise de regressão linear simples**, uma vez que se espera um aumento dessas concentrações com o passar do tempo. Em adição, as estimativas do coeficiente angular **β~1~** fornece informações importantes para uma determinada região, haja visto que se **β~1~'** (observado para essa região) for significativamente maior ao **β~1~** padrão (observado para uma macro-região), tal área poderá ser considerada uma potencial fonte de carbono para a atmosfera, caso contrário (**β~1~'** < **β~1~**), a área em questão poderá ser considerada um sumidouro de CO~2~ atmosférico, mitigando o efeito estufa adicional e, consequentemente, as mudanças climáticas globais. 

## Hipótese e objetivo

A hipótese do projeto é que essa tendência de aumento da concentração atmosférica de CO~2~ pode ser utilizada como um indicativo para a classificação de áreas como fontes e sumidouros de CO~2~ utilizando as estimativas de **β~1~** provenientes da análise de regressão linear simples.

## Material e Métodos

Para a aquisição de dados será utilizado metodologia desenvolvida e apresentada anteriormente no curso de R para Ciências de dados 2, ministrados pela Curso-r ([Projeto Final r4ds2](https://github.com/arpanosso/projetofinal_r4ds2)), onde foram utilizadas técnicas de *web scraping* e **faxina de dados** para obtenção dos valores de X~CO2~.


Breve descrição das variáveis da base:

**longitude**: coordenada geográfica que especifica a posição leste-oeste de um ponto na superfície da Terra;

**longitude_bnds**: são, respectivamente, os limites superior e inferior da coordenada, onde a **longitude** para um ponto foi dada pela média desses limites;

**latitude**: é uma coordenada geográfica que especifica a posição norte-sul de um ponto na superfície da Terra;

**latitude_bnds**: são, respectivamente, os limites superior e inferior da coordenada, onde a **latitude** para um ponto foi dada pela média desses limites;

**time_yyyymmddhhmmss**: data de leitura, em ano, mês, dia, horas minutos e segundos;

**time_bnds_yyyymmddhhmmss**: limites de tempo utilizados para o cálculo da data de leitura;

**altitude_km**: altitude média em km;

**alt_bnds_km**: limites da altitude, 0 (nível do mar) e altitude do satélite no momento de leitura;

**fluorescence_offset_relative_771nm_idp**: Fração de radiância de nível contínuo explicada por um termo de deslocamento aditivo na janela espectral de 757 nm (sem unidade);

**fluorescence_offset_relative_757nm_idp**: Fração da radiância de nível contínuo explicada por um termo de deslocamento aditivo na janela espectral de 771 nm (sem unidade);

**xco2_moles_mole_1**: Fração molar de ar seco de CO~2~ em média da coluna. 

```{r}
oco2 <- readr::read_rds("data/oco2.rds")
dplyr::glimpse(oco2)
```

Será necessário transformar os dados de X~CO2~, para ppm em seguida criar as variáveis de data a partir da variável `time_yyyymmddhhmmss`.

```{r}
oco2<-oco2 |>
         dplyr::mutate(
           xco2 = xco2_moles_mole_1*1e06,
           data = lubridate::ymd_hms(time_yyyymmddhhmmss),
           year = lubridate::year(data),
           month = lubridate::month(data),
           day = lubridate::day(data),
           day_week = lubridate::wday(data),
           month_year = lubridate::make_date(year, month, 1) )
```

Existe uma tendência de aumento monotônica mundial da concentração de CO~2~ na atmosfera, assim, ela deve ser modelada para obtermos **β~1~** para ser considerado o padrão para comparação às tendências  regionais. Devido à periodicidade de retorno do satélite em um ponto (ao redor de 16 dias) os dados serão agrupados pelo mês dentro de um determinado ano.


```{r, warning=FALSE, error=FALSE, message=FALSE}
oco2 |> 
  dplyr::group_by(month_year) |> 
  dplyr::summarise(xco2_mean = mean(xco2, na.rm =TRUE)) |> 
  ggplot2::ggplot(ggplot2::aes(x=month_year,y=xco2_mean )) +
  ggplot2::geom_point(shape=21,color="black",fill="gray") +
  ggplot2::geom_line(color="red") +
  ggplot2::geom_smooth(method = "lm") +
  ggpubr::stat_regline_equation(ggplot2::aes(
  label =  paste(..eq.label.., ..rr.label.., sep = "*plain(\",\")~~"))) +
  ggplot2::theme_bw()
```

Para ajustar o modelo linear, usamos `lm()`.

```{r, warning=FALSE, error=FALSE, message=FALSE}
oco2_aux <- oco2 |> 
  dplyr::group_by(month_year) |> 
  dplyr::summarise(xco2_mean = mean(xco2, na.rm =TRUE))
mod <- lm(xco2_mean ~ month_year, data = oco2_aux)
summary(mod)
```

```{r}
broom::augment(mod)
broom::augment(mod, interval="confidence")
plot(mod)
# cooks.distance(mod)
```

A próxima operação é selecionarmos na base de dados somente os pontos pertencentes ao território brasileiro. Assim vamos utilizar o pacote geobr para criarmos o filtro a partir do polígono do Brasil e regiões.

```{r}
regiao <- geobr::read_region(showProgress = FALSE)
br <- geobr::read_country(showProgress = FALSE)
```

Agora podemos extrair os polígonos


```{r}
### Polígono Brasil
pol_br <- br$geom |> purrr::pluck(1) |> as.matrix()

### Polígonos das Regiões
pol_norte <- regiao$geom |> purrr::pluck(1) |> as.matrix()
pol_nordeste <- regiao$geom |> purrr::pluck(2) |> as.matrix()
pol_sudeste <- regiao$geom |> purrr::pluck(3) |> as.matrix()
pol_sul <- regiao$geom |> purrr::pluck(4) |> as.matrix()
pol_centroeste<- regiao$geom |> purrr::pluck(5) |> as.matrix()
```


Plot dos pontos e o polígono.

```{r}
br |>
  ggplot2::ggplot() +
  ggplot2::geom_sf(fill="#2D3E50", color="#FEBF57",
          size=.15, show.legend = FALSE) +
  ggplot2::geom_point(data=oco2 |> dplyr::filter(year == 2014) ,
             ggplot2::aes(x=longitude,y=latitude),
             shape=3,
             col="red",
             alpha=0.2)
```
A partir da função `point.in.pol()` do pacote `{sp}`, criamos a função abaixo para facilitar o processo de filtragem em para de um polígono pré-definido.

```{r}
def_pol <- function(x, y, pol){
  as.logical(sp::point.in.polygon(point.x = x,
                                  point.y = y,
                                  pol.x = pol[,1],
                                  pol.y = pol[,2]))
}
```

Corrigindo as falhas do polígono e criando os polígonos para cada região do país.

```{r, eval=FALSE}
# Retirando alguns pontos
pol_br <- pol_br[pol_br[,1]<=-34,]
pol_br <- pol_br[!((pol_br[,1]>=-38.8 & pol_br[,1]<=-38.6) &
                              (pol_br[,2]>= -19 & pol_br[,2]<= -16)),]

pol_nordeste <- pol_nordeste[pol_nordeste[,1]<=-34,]
pol_nordeste <- pol_nordeste[!((pol_nordeste[,1]>=-38.7 & pol_nordeste[,1]<=-38.6) & pol_nordeste[,2]<= -15),]

# Criando as flags
oco2 <- oco2 |>
          dplyr::mutate(
            flag_br = def_pol(longitude, latitude, pol_br),
            flag_norte = def_pol(longitude, latitude, pol_norte),
            flag_nordeste = def_pol(longitude, latitude, pol_nordeste),
            flag_sul = def_pol(longitude, latitude, pol_sul),
            flag_sudeste = def_pol(longitude, latitude, pol_sudeste),
            flag_centroeste = def_pol(longitude, latitude, pol_centroeste)
            )
```

```{r,echo=FALSE}
oco2 <- readr::read_rds("data/oco2_br.rds")
```


```{r}
# Plot do mapa e os pontos
oco2<-oco2 |>
  dplyr::mutate(
    flag_br = flag_br | flag_nordeste
  )
br |>
  ggplot2::ggplot() +
  ggplot2::geom_sf(fill="#2D3E50", color="#FEBF57",
          size=.15, show.legend = FALSE) + 
  ggplot2::geom_point(data=oco2 |> 
                      dplyr::filter(flag_br, year == 2014),
             ggplot2::aes(x=longitude, y=latitude),
             shape=3,
             col="red",
             alpha=0.2)

```

Agora podemos guardar esses dados para realizar as análises futuras.

```{r, eval=FALSE}
oco2_br <- oco2 |>
  dplyr::filter( flag_br | flag_nordeste ) 
readr::write_rds(oco2_br,"data/oco2_br.rds")
```








